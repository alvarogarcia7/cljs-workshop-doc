cljs workshop
=============
Andrey Antukh, <niwi@niwi.be>
:toc: left
:numbered:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:


Why ClojureScript
-----------------

- Clojure is designed as guest language (unlike funscript or similar, it not intends to translate
  host code to js, you can not import java.util.Date on clojurescript...)
- Language with own semantics (not like coffeescript, typescript, ...)
- Good host interoperability.
- Batteries included (clojure runtime & google closure library)
- Expressivenes
- Functional.
- Lisp.
- Macros.
- Google Closure Compiller (advanced code compiling with dead code elimination)
- core.async (coroutines and csp as a library)
- ... much more.


Setup initial project
---------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git clone https://github.com/niwibe/cljs-workshop
git checkout step0
----

This step consists on...
~~~~~~~~~~~~~~~~~~~~~~~~

- Initial leiningen project template.
- Add ring, compojure and other related dependencies.
- Create routes and initial application entry point.
- First run of hello world app.


Initial project tree
~~~~~~~~~~~~~~~~~~~~~

[source, text]
----
resources/
resources/public/
resources/index.html
src/
src/clj/
src/clj/cljsworkshop/
src/clj/cljsworkshop/core.clj
project.clj
----

Initial *project.clj*
~~~~~~~~~~~~~~~~~~~~~

[source, clojure]
----
(defproject cljsworkshop "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "BSD (2-Clause)"
            :url "http://opensource.org/licenses/BSD-2-Clause"}
  :dependencies [[org.clojure/clojure "1.6.0"]

                 ;; Backend dependencies
                 [compojure "1.2.1"]
                 [ring/ring-core "1.3.1" :exclusions [javax.servlet/servlet-api]]
                 [ring/ring-servlet "1.3.1" :exclusions [javax.servlet/servlet-api]]
                 [ring/ring-defaults "0.1.2"]

                 [javax.servlet/javax.servlet-api "3.1.0"]
                 [info.sunng/ring-jetty9-adapter "0.7.2"]]

  :source-paths ["src/clj"]
  :main cljsworkshop.core)
----


Intial ring/compojure handlers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Ring handler consists in a simple function that receives a req (hash-map) and return a response (also hash-map).
- Compojure add routing handlers and some response helpers.
- jetty9 is a embedded http/application server.

._clj/cljsworkshop/core.clj_
[source, clojure]
----
(ns cljsworkshop.core
  (:require [ring.adapter.jetty9 :refer [run-jetty]]
            [compojure.core :refer :all]
            [compojure.route :as route]
            [compojure.response :refer [render]]
            [clojure.java.io :as io]))

(defn home
  [req]
  (render (io/resource "index.html") req))

(defroutes app
  (GET "/" [] home)
  (route/resources "/static")
  (route/not-found "<h1>Page not found</h1>"))

(defn -main
  [& args]
  (run-jetty app {:port 5050}))
----


Initial *index.html* file
~~~~~~~~~~~~~~~~~~~~~~~~

[source, html]
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CLJS Workshop</title>
  </head>
  <body>
    <h1>Hello World</h1>
  </body>
</html>
----


First steps with ClojureScript
------------------------------

Print to console
~~~~~~~~~~~~~~~~

[source, clojure]
----
(.log js/console "hello world")
----

[source, clojure]
----
(enable-console-print!)
(println "hello world")
----

Modules
~~~~~~~

.Declare module
[source, clojure]
----
(ns my.library)
----

.Require a module
[source, clojure]
----
(ns my.library
  (:require [my.other :as other]))
----


Variables
~~~~~~~~~

.Top level
[source, clojure]
----
(def myvar "foo")
----

.Local
[source, clojure]
----
(let [myvar "foo"]
  (println myvar))
----


Functions
~~~~~~~~~

.Simple function definition
[source, clojure]
----
(defn foo
  [a b c]
  c)

(foo 1) ;; WARNING: function called with incorrect
        ;; number of arguments

(foo 1 2 3) ;; => 3
----

.Dispatch on arity
[source, clojure]
----
(defn foo
  ([a] "one")
  ([a b] "two")
  ([a b c] "three"))

(foo 1) ;; => "one"
(foo 1 2) ;; => "two"
(foo 1 2 3) ;; => "three"

;; Under advanced compilation direct dispatch to
;; arity. No arguments object manipulation
----

.Variable number of arguments
[source, clojure]
----
(defn foo
  [a b & rest]
  rest)

(foo 1 2 3) ;; => [3]
(foo 1 2 3 4 5) ;; => [3 4 5]
----

.Named parameters & default values
[source, clojure]
----
(defn foo
  [& {:keys [bar baz]
      :or {bar "default1"
           baz "default2"}}]
  (str bar "-" baz))

(foo) ;; => "default1-default2"
(foo :bar 1) ;; => "1-default2"
(foo :bar 1 :baz 2) ;; => "1-2"
----

Equality
~~~~~~~~

Is always based on value. CLJS does not have coercive equality.

[source, javascript]
----
// == operator is coercive
1 == "1" // => true

// sometimes based on value
{} == {} // => false

["a"] === ["a"] // => false
----

[source, clojure]
----
(= 1 "1") ;; => false
(= {} {}) ;; => true
(= ["a"] ["a"]) ;; => true
----


Immutable locals
~~~~~~~~~~~~~~~~

In cljs locals are immutable:

.This code throws an error:
[source, clojure]
----
(let [x 2]
  (set! x 3))
----


Dynamic binding
~~~~~~~~~~~~~~~

[source, clojure]
----
(def ^:dynamic x 5)

(defn print-value
  []
  (println "Current value:" x))

(print-value)
(binding [x 10]
  (print-value))
(print-value)

;; Will result in:
;; Current value: 5
;; Current value: 10
;; Current value: 5
----

Destructuring
~~~~~~~~~~~~~

.Positional destructuring.
[source, clojure]
----
(def color [255 255 100 0.5])

(let [[r g _ a] color]
  (println r)
  (println a))

;; Will result in:
;; 255
;; 0.5
----

.Hash map keys destructuring
[source, clojure]
----
(def m {:first "Bob"
        :middle "J"
        :last "Smith"})

(let [{:keys [first last]} m]
  (println first)
  (println last))

;; Will result in:
;; Bob
;; Smith
----


Expression problem
~~~~~~~~~~~~~~~~~~

[source, clojure]
----
;; For example say you'd like to use RegExps
;; as functions

(extend-type js/RegExp
  IFn
  (-invoke
   ([this s]
     (re-matches this s))))

(filter #"foo.*" ["foo" "bar" "foobar"])
;; => ("foo" "foobar")
----

Multimethods
~~~~~~~~~~~~

Polymorphism a la carte.

.Define a multimethod
[source, clojure]
----
(defmulti say-hello
  (fn [person]
    (:lang person :en)))

(defmethod say-hello :en
  [person]
  (format "Hello %s" (:name person)))

(defmethod say-hello :es
  [person]
  (format "Hola %s" (:name person)))
----

.Playing with multimethod
[source, clojure]
----
(def person-alex {:lang :es :name "Alex"})
(def person-yen {:lang :en :name "Yen"})
(def person-anon {:name "Anonymous"}) 

(say-hello person-alex)
;; => "Hola Alex"

(say-hello person-yen)
;; => "Hello Yen"

(say-hello person-anon)
;; => "Hello Anonimous"
----


Interoprability
~~~~~~~~~~~~~~~

Create javascript objects
^^^^^^^^^^^^^^^^^^^^^^^^^

.Clojure
[source, clojure]
----
(def foo (js-obj "bar" "baz"))
----

.Javascript
[source, javascript]
----
var foo = {bar: "baz"};
----

Property access
^^^^^^^^^^^^^^^

.Clojure
[source, clojure]
----
(set! (.-bar foo) "baz")
(.log js/console (.-bar foo))

(aset foo "abc" 17)
(.log js/console (aget foo "abc"))
----

.Javascript
[source, javascript]
----
foo.bar = "baz";
console.log(foo.bar);

foo["abc"] = 17;
console.log(foo["abc"]);
----


Conversions beween cljs and js
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Convert cljs types to js using `clj->js` function
[source, clojure]
----
(let [a {:a 1 :b {:c 1}}]
  (clj->js a))
----

.Convert js types to cljs using `js->clj` function
[source, clojure]
----
(defn get-names [people]
  (let [people (js->clj people)
        names (map "name" people)]
    (clj->js names)))
----

.Using reader macro for conver cljs to js:
[source, clojure]
----
(let [a #js [1 2 3]]
  (println (aget a 1)))

;; Will result in:
;; 2
----

More
~~~~

http://himera.herokuapp.com/synonym.html


First ClojureScript Hello World
-------------------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step1
----

New dependencies on *project.clj*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
:dependencies [;; ...
               [org.clojure/clojurescript "0.0-2371"]
               ;; ...]
----


*lein-cljsbuild* plugin is your friend
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
:plugins [[lein-cljsbuild "1.0.3"]]
:cljsbuild {:builds
            [{:id "app"
              :source-paths ["src/cljs"]
              :compiler {:output-to "resources/public/js/app.js"
                         :optimizations :whitespace
                         :pretty-print true}}]}
----


New ClojureScript file.
~~~~~~~~~~~~~~~~~~~~~~~

New tree structure on `src/` directory for clojurescript sources.

[source, text]
----
src/cljs/
src/cljs/cljsworkshop/
src/cljs/cljsworkshop/core.cljs
----


Hello World in cljs
~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
(defn set-html! [el content]
  (set! (.-innerHTML el) content))

(defn main
  []
  (let [content "Hello World from Clojure Script"
        element (aget (js/document.getElementsByTagName "main") 0)]
    (set-html! element content)))
----


*index.html* changes
~~~~~~~~~~~~~~~~~~~~

[source, html]
----
<body>
  <main></main>
  <script src="/static/js/app.js"></script>
</body>
----


Compile our cljs file
~~~~~~~~~~~~~~~~~~~~~

[source, text]
----
[3/5.0.7]niwi@niwi:~/cljs-workshop> lein cljsbuild auto
Compiling ClojureScript.
Compiling "resources/public/js/app.js" from ["src/cljs"]...
Successfully compiled "resources/public/js/app.js" in 3.396 seconds.
----



First DOM events
----------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step2
----


*index.html* changes
~~~~~~~~~~~~~~~~~~~~

[source, html]
----
<main>
  <section>
    <span>Clicks: </span>
    <span id="clicksnumber"><span>
  </section>
  <button id="button">Click me</button>
</main>
----

New *main* function
~~~~~~~~~~~~~~~~~~~

[source, clojure]
----
(ns cljsworkshop.core
  (:require [goog.events :as events]
            [goog.dom :as dom]))

(defn main
  []
  (let [counter (atom 0)
        button  (dom/getElement "button")
        display (dom/getElement "clicksnumber")]

    ;; Set initial value
    (set! (.-innerHTML display) @counter)

    ;; Assign event listener
    (events/listen button "click"
                   (fn [event]
                     ;; Increment the value
                     (swap! counter inc)
                     ;; Set new value in display element
                     (set! (.-innerHTML display) @counter)))))

(main)
----

New stuff
~~~~~~~~~

- ClojureScript uses Google Closure Library for modules/namespace: *each ClojureScript file reprensents a google closure module*
- The `:require` statement on `ns` can loads any google closure module or your defined module that the compiller can find in the path (see _project.clj_ for path...)
- Google Closure Library comes with ClojureScript. You don't need add it as dependency.
- Works in advanced mode of google closure compiler (that eliminates unused code).

More documentation:

- http://himera.herokuapp.com/synonym.html


Routing in the browser
----------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step3
----

Add *secretary* dependency
~~~~~~~~~~~~~~~~~~~~~~~~~~

*secretary* is a routing library for clojure script.

._project.clj_
[source, clojure]
----
:dependencies [;; ...
               [secretary "1.2.1"]]
----


*core.cljs* changes
~~~~~~~~~~~~~~~~~~~

[source, clojure]
----
(ns cljsworkshop.core
  (:require-macros [secretary.core :refer [defroute]])
  (:require [goog.events :as events]
            [goog.dom :as dom]
            [secretary.core :as secretary])
  (:import goog.History))

(def app (dom/getElement "app"))

(defn set-html! [el content]
  (set! (.-innerHTML el) content))

(defroute home-path "/" []
  (set-html! app "<h1>Hello World from home page.</h1>"))

(defroute some-path "/:param" [param]
  (let [message (str "<h1>Parameter in url: <small>" param "</small>!</h1>")]
    (set-html! app message)))

(defroute "*" []
  (set-html! app "<h1>Not Found</h1>"))

(defn main
  []
  ;; Set secretary config for use the hashbang prefix
  (secretary/set-config! :prefix "#")

  ;; Attach event listener to history instance.
  (let [history (History.)]
    (events/listen history "navigate"
                   (fn [event]
                     (secretary/dispatch! (.-token event))))
    (.setEnabled history true)))

(main)
----

New stuff
~~~~~~~~~

- ClojureScript macros should be written in Clojure (not ClojureScript) but should emit ClojureScript code.
- Should be imported separatedly, using `(:require-macros ...)` statement on `ns`.
- Google closure classes should be imported with `(:import ...)` statement.


First steps with Ajax
---------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step4
----


*core.cljs* changes
~~~~~~~~~~~~~~~~~~~

.Partial content from _core.cljs_
[source, clojure]
----
(ns cljsworkshop.core
  (:require-macros [secretary.core :refer [defroute]])
  (:require [goog.events :as events]
            [goog.dom :as dom]
            [secretary.core :as secretary])
  (:import goog.History
           goog.Uri
           goog.net.Jsonp))


(def search-url "http://en.wikipedia.org/w/api.php?action=opensearch&format=json&search=")
(def home-html
  (str "<h1>Wikipedia Search:</h1>"
       "<section>"
       "  <input id=\"query\" placeholder=\"Type your search...\" />"
       "  <button id=\"searchbutton\">Search</button>"
       "  <ul id=\"results\"></ul>"
       "</section>"))

(defn render-results [results]
  (let [results (js->clj results)]
    (reduce (fn [acc result]
              (str acc "<li>" result "</li>"))
            ""
            (second results))))

(defn do-jsonp
  [uri callback]
  (let [req (Jsonp. (Uri. uri))]
    (.send req nil callback)))

(defroute home-path "/" []
  (set-html! app home-html)
  (let [on-response     (fn [results]
                          (let [html (render-results results)]
                            (set-html! (dom/getElement "results") html)))

        on-search-click (fn [e]
                          (let [userquery (.-value (dom/getElement "query"))
                                searchuri (str search-url userquery)]
                            (do-jsonp searchuri on-response)))]

    (events/listen (dom/getElement "searchbutton") "click" on-search-click)))
----

Introduction to core.async
--------------------------

Is a CSP library with steroids.


Async code looks sync
~~~~~~~~~~~~~~~~~~~~~

Let start with future ES7 (EcmaScript 7) proposal: `async` and `await`

.Having defined this two utils functions...
[source, javascript]
----
function timeout(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}

function httpGet(url) {
  return new Promise(function(resolve) {
    var req = new XMLHttpRequest();
    req.open("GET", url, false);
    req.send(null);
    req.onreadystatechange = function() {
      if (req.readyState == 4) {
        resolve(xhr.responseText);
      }
    }
  });
}
----

Solution using ES5
^^^^^^^^^^^^^^^^^^

Let start introducing a problem using ES5 (EcmaScript 5) or shortly javascript of
today:

1. Request 1 url page.
2. Wait 1second
3. Request 2 url page.
4. Return result both results.

[source, javascript]
----
function doStuff() {
   httpGet("http://page1/").then(function(response) {
    return timeout(1000).then(function() {
      return response;
    });
   })
   .then(function(response1) {
     return httpGet("http://page2/").then(function(response2) {
       return {response1: response1,
               response2: response2};
     });
   })
}
----

.Now you can use it so:
[source, javascript]
----
doStuff().then(function(result) {
  console.log(result.response1);
  console.log(result.response2);
});
----

Obviously, it can be done better, but nobody will save us from callbacs.


Solution using ES7
^^^^^^^^^^^^^^^^^^

But, what is cooking for ES7? (ES7? but ES6 still not ready? WTF)

.Same example but using the draft proposal for ES7 but is available for years in C#
[source, javascript]
----
async function doStuff() {
  var response1, response2;

  response1 = await httpGet("http://page1/");
  await timeout(1000):
  response2 = await httpGet("http://page2/");
  return {response1: response1,
          response2: response2};
}
----

.Now you can use it so:
[source, javascript]
----
(async function() {
  var result = await doStuff()
  console.log(result.response1);
  console.log(result.response2);
})();
----

Now looks much better.

Solution using cljs and core.async
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now having the background of ES7 example, let see same thing but using
core.async library with clojure script.

.Define the missing util function.
[source, clojure]
----
(defn http-get [uri]
  (let [out (chan)
        req (XhrIo. (Uri. uri))]
    (events/listen req "success" #(put! out (.getResponseText (.-target %))))
    (.send req (Uri. uri))
    out))
----

.Define the doStuff like function with main logic.
[source, clojure]
----
(defn do-stuff
  []
  (go
    (let [response1 (<! (http-get "http://page1/"))
          _         (<! (timeout 1000))
          response2 (<! (http-get "http://page2/"))]
      {:response1 response1
       :response2 response2})))
----

.Now see an example of how use it.
[source, clojure]
----
(go
  (let [result (<! (do-stuff))]
    (.log js/console (.-response1 result))
    (.log js/console (.-response2 result))))
----

A little reference of basic core.async components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *go* function/macro
^^^^^^^^^^^^^^^^^^^^^^^

[source, clojure]
----
(go
  [... do something asynchronously ...])
----

- always return a channel.
- put in a returned channel the restul of last expression.
- executes asynchronously.

The *chan* function
^^^^^^^^^^^^^^^^^^^

[source, clojure]
----
(chan)
----

- creates a new channel
- does not support nil values
- nil return value means channel is closed
- support different buffering strategies: fixed size, unbound (default), sliding, dropping.


The *<!* and *>!* functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^

[source, clojure]
----
(go
  (<! (timeout 100))
  (.log js/console "finished"))
----

- `<!` represents a callback-less `take!`
- `>!` represents a callback-less `put!`
- in clojure them have blocking version of them: `<!!` and `>!!` and they does not
  requires of go macro, because they blocks the current thread.

Other resources
^^^^^^^^^^^^^^^

- http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html
- http://yobriefca.se/blog/2014/06/01/combining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix/
- http://yobriefca.se/blog/2014/06/04/publish-and-subscribe-with-core-dot-asyncs-pub-and-sub/
- http://www.purelyfunctional.tv/core-async
- http://www.lispcast.com/elm-frp-in-core-async


Ajax with core.async
--------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step5
----

Why
~~~

- Callbacks sucks.
- Unclear execution flow.
- We can do it better!
- with core.async, async code looks sync ;)


Add *core.async* dependency
~~~~~~~~~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
:dependencies [;; ...
               [org.clojure/core.async "0.1.346.0-17112a-alpha"]]
----


*core.cljs* changes
~~~~~~~~~~~~~~~~~~~

.Partial content from _core.cljs_
[source, clojure]
----
(ns cljsworkshop.core
  (:require-macros [secretary.core :refer [defroute]]
                   [cljs.core.async.macros :refer [go]])
  (:require [goog.events :as events]
            [goog.dom :as dom]
            [secretary.core :as secretary]
            [cljs.core.async :refer [<! put! chan]])
  (:import goog.History
           goog.Uri
           goog.net.Jsonp))

(defn render-results [results]
  (let [results (js->clj results)]
    (reduce (fn [acc result]
              (str acc "<li>" result "</li>"))
            ""
            (second results))))

(defn listen [el type]
  (let [out (chan)]
    (events/listen el type (fn [e] (put! out e)))
    out))

(defn jsonp [uri]
  (let [out (chan)
        req (Jsonp. (Uri. uri))]
    (.send req nil (fn [res] (put! out res)))
    out))

(defroute home-path "/" []
  ;; Render initial html
  (set-html! app home-html)

  (let [clicks (listen (dom/getElement "searchbutton") "click")]
    (go (while true
          (<! clicks)
          (let [uri     (str search-url (.-value (dom/getElement "query")))
                results (<! (jsonp uri))]
            (set-html! (dom/getElement "results")
                       (render-results results)))))))
----

Now the code looks sync.


Hello World from Om component
-----------------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step6
----

Why
~~~

- Reactjs (functional approach for rendering dom)
- Global state management facilities built in.
- Customizable semantics. Fine grained control over how components store state.
- Out of the box snapshotable and undoable and these operations have no implementation
  complexity and little overhead.


First om component
~~~~~~~~~~~~~~~~~~

Befor see a complex app, we'll try understand the basic of om components.

[source, clojure]
----
(ns mysamplens
  (:require [om.core :as om :include-macros true]
            [sablono.core :as html :refer-macros [html]]))

(defn mycomponent
  [app owner]
  (reify
    ;; Mainly serves for debugging. Specifies the
    ;; display name of react component on react
    ;; debugging tools for Chrome.
    om/IDisplayName
    (display-name [_]
      "my-component")

    ;; Set the initial component state.
    om/IInitState
    (init-state [_]
      {:message "Hello world from local state"})

    ;; Render the component with current local state.
    om/IRenderState
    (render-state [_ {:keys [message]}]
      (html [:section
             [:div message]
             [:div (:message app)]]))))

----

*_reify_, what is this?*

_reify_ creates an anonymos object that implement one or more protocols.

_om_ components consists in any object that implements the `om/IRender` or
`om/IRenderState` protocols. Implementations for other protocols is optional.

In previous examples we have used a few number of protocols. Om comes with few other
but them comes out of this first example scope.

*Now, having defined a compoment, it a time to mount it.

[source, clojure]
----
(defonce state {:message "Hello world from global state."})

;; "app" is a id of dom element at index.html
(let [el (gdom/getElement "app")]
  (om/root mycomponent state {:target el}))
----

Time traveling with Om
----------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step7
----

Little introduction
~~~~~~~~~~~~~~~~~~~

- The state of aplication is serializable, that makes easy and in deterministic way to reproduce
  a concrete state of the application.
- The union of ClojureScript and Reactjs makes some task, that is usually considered very complex,
  very easy and painless, such as the time traveling or the undo in a few lines of code.
