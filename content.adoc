cljs workshop
=============
Andrey Antukh, <niwi@niwi.be>
:toc: left
:numbered:
:source-highlighter: pygments
:pygments-style: friendly

Why ClojureScript
-----------------

- Clojure is designed as guest language (unlike funscript or similar, it not intends to translate
  host code to js, you can not import java.util.Date on clojurescript...)
- Language with own semantics (not like coffeescript, typescript, ...)
- Good host interoperability.
- Batteries included (clojure runtime & google closure library)
- Expressivenes
- Functional.
- Lisp.
- Macros.
- Google Closure Compiller (advanced code compiling with dead code elimination)
- core.async (coroutines and csp as a library)
- ... much more.


Setup initial project
---------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git clone https://github.com/niwibe/cljs-workshop
git checkout step0
----

This step consists on...
~~~~~~~~~~~~~~~~~~~~~~~~

- Initial leiningen project template.
- Add ring, compojure and other related dependencies.
- Create routes and initial application entry point.
- First run of hello world app.


Initial project tree
~~~~~~~~~~~~~~~~~~~~~

[source, text]
----
resources/
resources/public/
resources/index.html
src/
src/clj/
src/clj/cljsworkshop/
src/clj/cljsworkshop/core.clj
project.clj
----

Initial *project.clj*
~~~~~~~~~~~~~~~~~~~~~

[source, clojure]
----
(defproject cljsworkshop "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "BSD (2-Clause)"
            :url "http://opensource.org/licenses/BSD-2-Clause"}
  :dependencies [[org.clojure/clojure "1.6.0"]

                 ;; Backend dependencies
                 [compojure "1.2.1"]
                 [ring/ring-core "1.3.1" :exclusions [javax.servlet/servlet-api]]
                 [ring/ring-servlet "1.3.1" :exclusions [javax.servlet/servlet-api]]
                 [ring/ring-defaults "0.1.2"]

                 [javax.servlet/javax.servlet-api "3.1.0"]
                 [info.sunng/ring-jetty9-adapter "0.7.2"]]

  :source-paths ["src/clj"]
  :main cljsworkshop.core)
----


Intial ring/compojure handlers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Ring handler consists in a simple function that receives a req (hash-map) and return a response (also hash-map).
- Compojure add routing handlers and some response helpers.
- jetty9 is a embedded http/application server.

._clj/cljsworkshop/core.clj_
[source, clojure]
----
(ns cljsworkshop.core
  (:require [ring.adapter.jetty9 :refer [run-jetty]]
            [compojure.core :refer :all]
            [compojure.route :as route]
            [compojure.response :refer [render]]
            [clojure.java.io :as io]))

(defn home
  [req]
  (render (io/resource "index.html") req))

(defroutes app
  (GET "/" [] home)
  (route/resources "/static")
  (route/not-found "<h1>Page not found</h1>"))

(defn -main
  [& args]
  (run-jetty app {:port 5050}))
----

Initial *index.html* file
~~~~~~~~~~~~~~~~~~~~~~~~

[source, html]
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CLJS Workshop</title>
  </head>
  <body>
    <h1>Hello World</h1>
  </body>
</html>
----


First steps with ClojureScript
------------------------------

Print to console
~~~~~~~~~~~~~~~~

[source, clojure]
----
(.log js/console "hello world")
----

[source, clojure]
----
(enable-console-print!)
(println "hello world")
----

Modules
~~~~~~~

.Declare module
[source, clojure]
----
(ns my.library)
----

.Require a module
[source, clojure]
----
(ns my.library
  (:require [my.other :as other]))
----


Variables
~~~~~~~~~

.Top level
[source, clojure]
----
(def myvar "foo")
----

.Local
[source, clojure]
----
(let [myvar "foo"]
  (println myvar))
----


Functions
~~~~~~~~~

.Simple function definition
[source, clojure]
----
(defn foo
  [a b c]
  c)

(foo 1) ;; WARNING: function called with incorrect
        ;; number of arguments

(foo 1 2 3) ;; => 3
----

.Dispatch on arity
[source, clojure]
----
(defn foo
  ([a] "one")
  ([a b] "two")
  ([a b c] "three"))

(foo 1) ;; => "one"
(foo 1 2) ;; => "two"
(foo 1 2 3) ;; => "three"

;; Under advanced compilation direct dispatch to
;; arity. No arguments object manipulation
----

.Variable number of arguments
[source, clojure]
----
(defn foo
  [a b & rest]
  rest)

(foo 1 2 3) ;; => [3]
(foo 1 2 3 4 5) ;; => [3 4 5]
----

.Named parameters & default values
[source, clojure]
----
(defn foo
  [& {:keys [bar baz]
      :or {bar "default1"
           baz "default2"}}]
  (str bar "-" baz))

(foo) ;; => "default1-default2"
(foo :bar 1) ;; => "1-default2"
(foo :bar 1 :baz 2) ;; => "1-2"
----

Equality
~~~~~~~~

Is always based on value. CLJS does not have coercive equality.

[source, javascript]
----
// == operator is coercive
1 == "1" // => true

// sometimes based on value
{} == {} // => false

["a"] === ["a"] // => false
----

[source, clojure]
----
(= 1 "1") ;; => false
(= {} {}) ;; => true
(= ["a"] ["a"]) ;; => true
----


Immutable locals
~~~~~~~~~~~~~~~~

In cljs locals are immutable:

.This code throws an error:
[source, clojure]
----
(let [x 2]
  (set! x 3))
----


Dynamic binding
~~~~~~~~~~~~~~~

[source, clojure]
----
(def ^:dynamic x 5)

(defn print-value
  []
  (println "Current value:" x))

(print-value)
(binding [x 10]
  (print-value))
(print-value)

;; Will result in:
;; Current value: 5
;; Current value: 10
;; Current value: 5
----

Destructuring
~~~~~~~~~~~~~

.Positional destructuring.
[source, clojure]
----
(def color [255 255 100 0.5])

(let [[r g _ a] color]
  (println r)
  (println a))

;; Will result in:
;; 255
;; 0.5
----

.Hash map keys destructuring
[source, clojure]
----
(def m {:first "Bob"
        :middle "J"
        :last "Smith"})

(let [{:keys [first last]} m]
  (println first)
  (println last))

;; Will result in:
;; Bob
;; Smith
----


Expression problem
~~~~~~~~~~~~~~~~~~

[source, clojure]
----
;; For example say you'd like to use RegExps
;; as functions

(extend-type js/RegExp
  IFn
  (-invoke
   ([this s]
     (re-matches this s))))

(filter #"foo.*" ["foo" "bar" "foobar"])
;; => ("foo" "foobar")
----

Multimethods
~~~~~~~~~~~~

Polymorphism a la carte.

.Define a multimethod
[source, clojure]
----
(defmulti say-hello
  (fn [person]
    (:lang person :en)))

(defmethod say-hello :en
  [person]
  (format "Hello %s" (:name person)))

(defmethod say-hello :es
  [person]
  (format "Hola %s" (:name person)))
----

.Playing with multimethod
[source, clojure]
----
(def person-alex {:lang :es :name "Alex"})
(def person-yen {:lang :en :name "Yen"})
(def person-anon {:name "Anonymous"}) 

(say-hello person-alex)
;; => "Hola Alex"

(say-hello person-yen)
;; => "Hello Yen"

(say-hello person-anon)
;; => "Hello Anonimous"
----

Interoprability
~~~~~~~~~~~~~~~

Create javascript objects
^^^^^^^^^^^^^^^^^^^^^^^^^

.Clojure
[source, clojure]
----
(def foo (js-obj "bar" "baz"))
----

.Javascript
[source, javascript]
----
var foo = {bar: "baz"};
----

Property access
^^^^^^^^^^^^^^^

.Clojure
[source, clojure]
----
(set! (.-bar foo) "baz")
(.log js/console (.-bar foo))

(aset foo "abc" 17)
(.log js/console (aget foo "abc"))
----

.Javascript
[source, javascript]
----
foo.bar = "baz";
console.log(foo.bar);

foo["abc"] = 17;
console.log(foo["abc"]);
----


Conversions beween cljs and js
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Convert cljs types to js using `clj->js` function
[source, clojure]
----
(let [a {:a 1 :b {:c 1}}]
  (clj->js a))
----

.Convert js types to cljs using `js->clj` function
[source, clojure]
----
(defn get-names [people]
  (let [people (js->clj people)
        names (map "name" people)]
    (clj->js names)))
----

.Using reader macro for conver cljs to js:
[source, clojure]
----
(let [a #js [1 2 3]]
  (println (aget a 1)))

;; Will result in:
;; 2
----

More
~~~~

http://himera.herokuapp.com/synonym.html


First ClojureScript Hello World
-------------------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step1
----

New dependencies on *project.clj*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
:dependencies [;; ...
               [org.clojure/clojurescript "0.0-2371"]
               ;; ...]
----


*lein-cljsbuild* plugin is your friend
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
:plugins [[lein-cljsbuild "1.0.3"]]
:cljsbuild {:builds
            [{:id "app"
              :source-paths ["src/cljs"]
              :compiler {:output-to "resources/public/js/app.js"
                         :optimizations :whitespace
                         :pretty-print true}}]}
----


New ClojureScript file.
~~~~~~~~~~~~~~~~~~~~~~~

New tree structure on `src/` directory for clojurescript sources.

[source, text]
----
src/cljs/
src/cljs/cljsworkshop/
src/cljs/cljsworkshop/core.cljs
----


Hello World in cljs
~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
(defn set-html! [el content]
  (set! (.-innerHTML el) content))

(defn main
  []
  (let [content "Hello World from Clojure Script"
        element (aget (js/document.getElementsByTagName "main") 0)]
    (set-html! element content)))
----


*index.html* changes
~~~~~~~~~~~~~~~~~~~~

[source, html]
----
<body>
  <main></main>
  <script src="/static/js/app.js"></script>
</body>
----


Compile our cljs file
~~~~~~~~~~~~~~~~~~~~~

[source, text]
----
[3/5.0.7]niwi@niwi:~/cljs-workshop> lein cljsbuild auto
Compiling ClojureScript.
Compiling "resources/public/js/app.js" from ["src/cljs"]...
Successfully compiled "resources/public/js/app.js" in 3.396 seconds.
----



First DOM events
----------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step2
----


*index.html* changes
~~~~~~~~~~~~~~~~~~~~

[source, html]
----
<main>
  <section>
    <span>Clicks: </span>
    <span id="clicksnumber"><span>
  </section>
  <button id="button">Click me</button>
</main>
----

New *main* function
~~~~~~~~~~~~~~~~~~~

[source, clojure]
----
(ns cljsworkshop.core
  (:require [goog.events :as events]
            [goog.dom :as dom]))

(defn main
  []
  (let [counter (atom 0)
        button  (dom/getElement "button")
        display (dom/getElement "clicksnumber")]

    ;; Set initial value
    (set! (.-innerHTML display) @counter)

    ;; Assign event listener
    (events/listen button "click"
                   (fn [event]
                     ;; Increment the value
                     (swap! counter inc)
                     ;; Set new value in display element
                     (set! (.-innerHTML display) @counter)))))

(main)
----

New stuff
~~~~~~~~~

- ClojureScript uses Google Closure Library for modules/namespace: *each ClojureScript file reprensents a google closure module*
- The `:require` statement on `ns` can loads any google closure module or your defined module that the compiller can find in the path (see _project.clj_ for path...)
- Google Closure Library comes with ClojureScript. You don't need add it as dependency.
- Works in advanced mode of google closure compiler (that eliminates unused code).

More documentation:

- http://himera.herokuapp.com/synonym.html


Routing in the browser
----------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step3
----

Add *secretary* dependency
~~~~~~~~~~~~~~~~~~~~~~~~~~

*secretary* is a routing library for clojure script.

._project.clj_
[source, clojure]
----
:dependencies [;; ...
               [secretary "1.2.1"]]
----


*core.cljs* changes
~~~~~~~~~~~~~~~~~~~

[source, clojure]
----
(ns cljsworkshop.core
  (:require-macros [secretary.core :refer [defroute]])
  (:require [goog.events :as events]
            [goog.dom :as dom]
            [secretary.core :as secretary])
  (:import goog.History))

(def app (dom/getElement "app"))

(defn set-html! [el content]
  (set! (.-innerHTML el) content))

(defroute home-path "/" []
  (set-html! app "<h1>Hello World from home page.</h1>"))

(defroute some-path "/:param" [param]
  (let [message (str "<h1>Parameter in url: <small>" param "</small>!</h1>")]
    (set-html! app message)))

(defroute "*" []
  (set-html! app "<h1>Not Found</h1>"))

(defn main
  []
  ;; Set secretary config for use the hashbang prefix
  (secretary/set-config! :prefix "#")

  ;; Attach event listener to history instance.
  (let [history (History.)]
    (events/listen history "navigate"
                   (fn [event]
                     (secretary/dispatch! (.-token event))))
    (.setEnabled history true)))

(main)
----

New stuff
~~~~~~~~~

- ClojureScript macros should be written in Clojure (not ClojureScript) but should emit ClojureScript code.
- Should be imported separatedly, using `(:require-macros ...)` statement on `ns`.
- Google closure classes should be imported with `(:import ...)` statement.


First steps with Ajax
---------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step4
----


*core.cljs* changes
~~~~~~~~~~~~~~~~~~~

.Partial content from _core.cljs_
[source, clojure]
----
(ns cljsworkshop.core
  (:require-macros [secretary.core :refer [defroute]])
  (:require [goog.events :as events]
            [goog.dom :as dom]
            [secretary.core :as secretary])
  (:import goog.History
           goog.Uri
           goog.net.Jsonp))


(def search-url "http://en.wikipedia.org/w/api.php?action=opensearch&format=json&search=")
(def home-html
  (str "<h1>Wikipedia Search:</h1>"
       "<section>"
       "  <input id=\"query\" placeholder=\"Type your search...\" />"
       "  <button id=\"searchbutton\">Search</button>"
       "  <ul id=\"results\"></ul>"
       "</section>"))

(defn render-results [results]
  (let [results (js->clj results)]
    (reduce (fn [acc result]
              (str acc "<li>" result "</li>"))
            ""
            (second results))))

(defn do-jsonp
  [uri callback]
  (let [req (Jsonp. (Uri. uri))]
    (.send req nil callback)))

(defroute home-path "/" []
  (set-html! app home-html)
  (let [on-response     (fn [results]
                          (let [html (render-results results)]
                            (set-html! (dom/getElement "results") html)))

        on-search-click (fn [e]
                          (let [userquery (.-value (dom/getElement "query"))
                                searchuri (str search-url userquery)]
                            (do-jsonp searchuri on-response)))]

    (events/listen (dom/getElement "searchbutton") "click" on-search-click)))
----


Ajax with core.async
--------------------

Let start with
~~~~~~~~~~~~~~

[source, text]
----
git reset --hard
git checkout step5
----


Why
~~~

- Callbacks sucks.
- Unclear execution flow.
- We can do it better!
- with core.async, async code looks sync ;)


Add *core.async* dependency
~~~~~~~~~~~~~~~~~~~~~~~~~~~

._project.clj_
[source, clojure]
----
:dependencies [;; ...
               [org.clojure/core.async "0.1.346.0-17112a-alpha"]]
----


*core.cljs* changes
~~~~~~~~~~~~~~~~~~~

.Partial content from _core.cljs_
[source, clojure]
----
(ns cljsworkshop.core
  (:require-macros [secretary.core :refer [defroute]]
                   [cljs.core.async.macros :refer [go]])
  (:require [goog.events :as events]
            [goog.dom :as dom]
            [secretary.core :as secretary]
            [cljs.core.async :refer [<! put! chan]])
  (:import goog.History
           goog.Uri
           goog.net.Jsonp))

(defn render-results [results]
  (let [results (js->clj results)]
    (reduce (fn [acc result]
              (str acc "<li>" result "</li>"))
            ""
            (second results))))

(defn listen [el type]
  (let [out (chan)]
    (events/listen el type (fn [e] (put! out e)))
    out))

(defn jsonp [uri]
  (let [out (chan)
        req (Jsonp. (Uri. uri))]
    (.send req nil (fn [res] (put! out res)))
    out))

(defroute home-path "/" []
  ;; Render initial html
  (set-html! app home-html)

  (let [clicks (listen (dom/getElement "searchbutton") "click")]
    (go (while true
          (<! clicks)
          (let [uri     (str search-url (.-value (dom/getElement "query")))
                results (<! (jsonp uri))]
            (set-html! (dom/getElement "results")
                       (render-results results)))))))
----

Now the code looks sync.